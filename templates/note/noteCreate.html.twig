{% extends '/user/dashboard/layout.html.twig' %}
{% block dashboard_main %}
    <style>
        .form-container {
            padding-top: 4em;
        }
        .form-header {
            margin-bottom: 1em;
        }
        .button-group {
            display: flex;
            align-items: center;
            margin-top: 0.5em;
        }
        .button-group a {
            margin-left: 1em;
        }
        .divider {
            font-size: 1.5em;
            display: flex;
            align-items: center;
        }
        .divider::before,
        .divider::after {
            flex: 1;
            content: '';
            padding: 1px;
            background-color: #bbbb;
            margin: 2em !important;
        }
        #box {
            margin-bottom: 1.5rem;
            padding: 0.5rem;
            border: 1px solid #ced4da;
            border-radius: 6px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, .1);
            background: rgba(255, 255, 255, .9);
            transition: background-color .3s ease;
        }
        #box:hover {
            background-color: #e9ecef;
        }

        #encrypting-overlay {
            position: fixed;
            inset: 0;
            background: rgba(255, 255, 255, .9);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 9999;
        }

        .spinner {
            border: 6px solid #ccc;
            border-top: 6px solid #333;
            border-radius: 50%;
            width: 60px;
            height: 60px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>

    <div class="transactions-section">
        <h2 style="padding-top: 2em;">{{ 'dashboard.create_your_secure_envelope'|trans }}</h2>
        <p>{{ 'create_your_secure_envelope_text'|trans|raw }}</p>

        <div class="tooltip_text mb-4">{{ 'dashboard.create_your_secure_envelope_tip'|trans }}</div>

        <!-- Toggle Encrypt in Browser (Default On) -->
        <div class="form-check form-switch mb-4">
            <input class="form-check-input" type="checkbox" id="frontendEncrypted" checked>
            <label class="form-check-label" for="frontendEncrypted">
                {{ 'dashboard.create_your_secure_envelope_switch'|trans|raw }}
            </label>
        </div>

        {{ form_start(form) }}
        {{ form_row(form.customerText) }}

        <div class="divider">{{ 'your_questions'|trans }}</div>
        <p>{{ 'your_questions_explain'|trans }}</p>
        {{ form_row(form.customerFirstQuestion) }}
        {{ form_row(form.customerFirstQuestionAnswer) }}
        {{ form_row(form.customerSecondQuestion) }}
        {{ form_row(form.customerSecondQuestionAnswer) }}

        {{ form_row(form._token) }}

        <div class="divider">{{ 'heir_questions'|trans }}</div>
        <p>{{ 'heir_questions_explain'|trans }}</p>

        <script src="https://cdn.jsdelivr.net/npm/argon2-browser@1.18.0/dist/argon2-bundled.min.js"></script>
        <script>
            // Global crash reporter
            window.onerror = function(msg, src, line, col, err) {
                // alert('window.onerror: ' + msg + '\n' + (err && err.stack ? err.stack : (src+':'+line+':'+col)));
            };

            // const say = (m) => { console.log('[CreateNote]', m); alert(m); };

            // Pull real IDs and full_names from server-rendered form (no guessing)
            const IDS = {
                note: "{{ form.customerText.vars.id }}",                    // e.g., note_creation_customerText
                a1:   "{{ form.customerFirstQuestionAnswer.vars.id }}",     // base id; we’ll use _first/_second
                a2:   "{{ form.customerSecondQuestionAnswer.vars.id }}",
                b1:   "{{ form.beneficiaryFirstQuestionAnswer.vars.id }}",
                b2:   "{{ form.beneficiarySecondQuestionAnswer.vars.id }}",
            };

            const NAMES = {
                frontendEncrypted: "{{ form.frontendEncrypted.vars.full_name }}",

                a1: [
                    "{{ form.customerTextAnswerOne.vars.full_name }}",
                    "{{ form.customerTextAnswerOneKms2.vars.full_name }}",
                    "{{ form.customerTextAnswerOneKms3.vars.full_name }}",
                ],
                a2: [
                    "{{ form.customerTextAnswerTwo.vars.full_name }}",
                    "{{ form.customerTextAnswerTwoKms2.vars.full_name }}",
                    "{{ form.customerTextAnswerTwoKms3.vars.full_name }}",
                ],
                b1: [
                    "{{ form.beneficiaryTextAnswerOne.vars.full_name }}",
                    "{{ form.beneficiaryTextAnswerOneKms2.vars.full_name }}",
                    "{{ form.beneficiaryTextAnswerOneKms3.vars.full_name }}",
                ],
                b2: [
                    "{{ form.beneficiaryTextAnswerTwo.vars.full_name }}",
                    "{{ form.beneficiaryTextAnswerTwoKms2.vars.full_name }}",
                    "{{ form.beneficiaryTextAnswerTwoKms3.vars.full_name }}",
                ],
            };

            function featureChecks() {
                const ok = !!(window.crypto && crypto.subtle);
                // say('WebCrypto: ' + (ok ? 'OK' : 'MISSING'));
                // say('HKDF supported? (deriveKey present): ' + (crypto.subtle && typeof crypto.subtle.deriveKey === 'function'));
                // say('Argon2 present? ' + !!(window.argon2 && window.argon2.hash));
            }

            async function fetchAllTokens() {
                // say('Fetching /api/note-tokens…');
                const res = await fetch('/api/note-tokens', { credentials: 'same-origin' });
                // say('Tokens response status: ' + res.status);
                const data = await res.json();
                // say('Tokens payload keys: ' + Object.keys(data).join(','));
                if (!data?.tokens || data.tokens.length !== 3) throw new Error('invalid tokens payload');
                // say('Got 3 tokens');
                return data.tokens; // base64
            }

            async function deriveUserKey(answer) {
                // say('Argon2 hashing… len=' + answer.length);
                const salt = crypto.getRandomValues(new Uint8Array(16));
                const res = await window.argon2.hash({
                    pass: new TextEncoder().encode(answer),
                    salt,
                    time: 5,
                    mem: 65536,
                    parallelism: 1,
                    hashLen: 32,
                    type: window.argon2.ArgonType.Argon2id,
                    raw: true
                });
                // say('Argon2 done');
                return { userKey: new Uint8Array(res.hash), salt };
            }

            async function aesGcmEncrypt(finalKey, plaintext) {
                const iv = crypto.getRandomValues(new Uint8Array(12));
                // say('AES-GCM encrypt…');
                const ct = await crypto.subtle.encrypt(
                    { name: 'AES-GCM', iv },
                    finalKey,
                    new TextEncoder().encode(plaintext)
                );
                // say('AES-GCM done');
                return {
                    c: btoa(String.fromCharCode(...new Uint8Array(ct))),
                    iv: btoa(String.fromCharCode(...iv))
                };
            }

            const b64ToBytes = (b64) => {
                // say('b64ToBytes len=' + b64.length);
                return Uint8Array.from(atob(b64), c => c.charCodeAt(0));
            };

            function setByFullName(form, fullName, value) {
                // say('Setting field: ' + fullName + ' (len=' + String(value).length + ')');
                let el = form.querySelector('[name="' + fullName.replace(/"/g, '\\"') + '"]');
                if (!el) {
                    el = document.createElement('input');
                    el.type = 'hidden';
                    el.name = fullName;
                    form.appendChild(el);
                    // say('Created hidden: ' + fullName);
                }
                el.value = value;
            }

            function readRepeated(baseId, mustMatch = true) {
                const first  = document.querySelector('#' + baseId + '_first')?.value ?? '';
                const second = document.querySelector('#' + baseId + '_second')?.value ?? '';
                // say('Read ' + baseId + ': first_len=' + first.length + ' second_len=' + second.length);
                if (!first) return '';
                if (mustMatch && second && first !== second) {
                    // alert('Answers do not match.');
                    throw new Error(baseId + ': mismatch');
                }
                return first;
            }

            document.addEventListener('submit', async (e) => {
                const form = e.target;
                if (!(form instanceof HTMLFormElement)) return;

                const frontendToggle = document.getElementById('frontendEncrypted'); // your checkbox id
                const offline = frontendToggle && frontendToggle.checked;
                // say('Frontend toggle checked? ' + !!offline);
                if (!offline) return;

                e.preventDefault();

                const overlay = document.getElementById('encrypting-overlay');
                if (overlay) {
                    overlay.style.display = 'flex';
                    // say('Overlay shown');
                }

                try {
                    featureChecks();

                    const note = document.querySelector('#' + IDS.note)?.value ?? '';
                    // say('Note length: ' + note.length);

                    const a1 = readRepeated(IDS.a1);
                    const a2 = readRepeated(IDS.a2, false);
                    const b1 = readRepeated(IDS.b1);
                    const b2 = readRepeated(IDS.b2, false);

                    if (!note || !a1 || !b1) {
                        // say('Missing required note/a1/b1 -> submitting without FE encryption');
                        if (overlay) overlay.style.display = 'none';
                        form.submit();
                        return;
                    }

                    const tokens = await fetchAllTokens();

                    // Flag for backend
                    setByFullName(form, NAMES.frontendEncrypted, '1');

                    const answers = { a1, a2, b1, b2 };
                    for (const [key, ans] of Object.entries(answers)) {
                        if (!ans) {
                            // say('Skip ' + key + ' (empty)');
                            continue;
                        }

                        const { userKey, salt } = await deriveUserKey(ans);

                        // Some engines expect algorithm as object on importKey for HKDF
                        // say('Import HKDF IKM…');
                        const hkdfKey = await crypto.subtle.importKey(
                            'raw',
                            userKey,
                            { name: 'HKDF' },
                            false,
                            ['deriveKey', 'deriveBits']
                        );
                        // say('HKDF IKM imported');

                        for (let i = 0; i < 3; i++) {
                            // say(`Replica ${i+1} for ${key}`);
                            const tokenBytes = b64ToBytes(tokens[i]);

                            // say('HKDF deriveKey…');
                            const finalKey = await crypto.subtle.deriveKey(
                                { name: 'HKDF', hash: 'SHA-256', salt: tokenBytes, info: new Uint8Array([1]) },
                                hkdfKey,
                                { name: 'AES-GCM', length: 256 },
                                false,
                                ['encrypt']
                            );
                            // say('HKDF deriveKey done');

                            const enc = await aesGcmEncrypt(finalKey, note);
                            const payload = JSON.stringify({
                                c: enc.c,
                                iv: enc.iv,
                                s: btoa(String.fromCharCode(...salt))
                            });

                            const fullName = NAMES[key][i];
                            setByFullName(form, fullName, payload);
                        }
                    }

                    // say('Submitting form now…');
                    form.submit();
                } catch (err) {
                    console.error(err);
                    // alert('Encrypt-on-submit failed: ' + (err && err.message ? err.message : err) + '\n' + (err && err.stack ? err.stack : 'no stack'));
                    form.submit(); // fail open
                } finally {
                    // if (overlay) { overlay.style.display = 'none'; say('Overlay hidden'); }
                }
            });
        </script>


        {{ form_end(form) }}
    </div>

    {% for label, messages in app.flashes %}
        {% for message in messages %}
            <div class="alert alert-{{ label }}">{{ message }}</div>
        {% endfor %}
    {% endfor %}

    <div id="encrypting-overlay">
        <div class="overlay-content" style="text-align:center;">
            <h2>{{ 'overlay_encrypting'|trans }} </h2>
            <p>{{ 'overlay_wait'|trans }} </p>
            <div class="spinner"></div>
        </div>
    </div>
{% endblock %}
